{"meta":{"title":"晓琳","subtitle":"","description":"","author":"晓琳","url":"https://codelin666.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-07-12T06:49:27.000Z","updated":"2020-07-12T07:01:03.361Z","comments":true,"path":"tags/index.html","permalink":"https://codelin666.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA中实现Singleton模式","slug":"JAVA中实现Singleton模式","date":"2020-07-19T06:42:00.084Z","updated":"2020-07-19T06:41:43.119Z","comments":true,"path":"2020/07/19/JAVA中实现Singleton模式/","link":"","permalink":"https://codelin666.github.io/2020/07/19/JAVA%E4%B8%AD%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JAVA中实现Singleton模式单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 单例模式写法双重检查Double-Checkpublic class Singleton { private static volatile Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }volatile关键字千万不能掉，禁止指令重排序优化 静态内部类public class Singleton { private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } }这种方式跟饿汉式方式采用的机制类似，但是可以延迟加载，并且线程安全，推荐使用。类的静态属性只会在第一次加载的时候被初始化，所以这是从JVM底层上保证了线程的安全性。 枚举public enum Singleton { INSTANCE; public void whateverMethod() { } }JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 单例模式的优缺点优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 缺点 单例模式一般没有接口，扩展很困难","categories":[],"tags":[]}],"categories":[],"tags":[]}