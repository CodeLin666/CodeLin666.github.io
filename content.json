{"meta":{"title":"晓琳","subtitle":"","description":"","author":"晓琳","url":"https://codelin666.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-07-12T06:49:27.000Z","updated":"2020-07-12T07:01:03.361Z","comments":true,"path":"tags/index.html","permalink":"https://codelin666.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"淦，跨域问题 ","slug":"淦，跨域问题 ","date":"2021-05-23T06:36:00.504Z","updated":"2021-07-23T06:28:05.177Z","comments":true,"path":"2021/05/23/淦，跨域问题 /","link":"","permalink":"https://codelin666.github.io/2021/05/23/%E6%B7%A6%EF%BC%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%20/","excerpt":"","text":"@Configuration public class CrosConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;) .allowCredentials(true) .maxAge(3600) .allowedHeaders(&quot;*&quot;); } }","categories":[],"tags":[]},{"title":"土到极致就是潮 ","slug":"土到极致就是潮 ","date":"2021-03-23T06:35:47.749Z","updated":"2021-07-23T06:30:14.962Z","comments":true,"path":"2021/03/23/土到极致就是潮 /","link":"","permalink":"https://codelin666.github.io/2021/03/23/%E5%9C%9F%E5%88%B0%E6%9E%81%E8%87%B4%E5%B0%B1%E6%98%AF%E6%BD%AE%20/","excerpt":"","text":"土到极致就是潮 一个在线的电子相册，哄女朋友就好使，直接可以发出来 效果不亚于某宝的土味礼物 没服务器也没关系，可以使用github或者gitee的页面托管，我下面的网址就是托管在gitee上了 建立一个文件夹，照片命名并保存 可以生成静态页面，然后就可以访问了 演示地址http://codelin666.gitee.io/album &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;电子相册&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html{ width: 100%; height: 100%; } .bigbox{ width: 10px; height: 10px; margin: 200px 400px; position: relative; } .box{ width:500px; height:300px; margin: 0 auto; transform-style: preserve-3d; transform: rotateX(-30deg) rotateY(-80deg); -webkit-animation: mystyle 15s infinite; animation-timing-function: linear; } @-webkit-keyframes mystyle{ from{transform: rotateX(-180deg) rotateY(-180deg);} to{transform: rotateX(180deg) rotateY(180deg);} } .box div{ position: absolute; width: 200px; height: 200px; opacity: 0.8; transition: all .4s; } .bigpic{ width: 200px; height: 200px; } .box .bigfront{ transform: rotateY(0deg) translateZ(100px); } .box .bigback{ transform: translateZ(-100px) rotateY(180deg); } .box .bigleft{ transform: rotateY(90deg) translateZ(100px); } .box .bigright{ transform: rotateY(-90deg) translateZ(100px); } .box .bigtop{ transform: rotateX(90deg) translateZ(100px); } .box .bigbottom{ transform: rotateX(-90deg) translateZ(100px); } .box span{ display: block; position: absolute; width: 140px; height: 140px; top: 25px; left: 25px; } .box .smallpic{ width: 140px; height: 140px; } .box .smallleft{ transform: rotateY(90deg) translateZ(70px); } .box .smallright{ transform: rotateY(-90deg) translateZ(70px); } .box .smalltop{ transform: rotateX(90deg) translateZ(70px); } .box .smallbottom{ transform: rotateX(-90deg) translateZ(70px); } .box .smallfront{ transform: rotateY(0deg) translateZ(70px); } .box .smallback{ transform: translateZ(-70px) rotateY(180deg); } /*:hover 我们之前说过的一个css选择器，能够让鼠标指向的时候触发*/ .box:hover .bigleft{ transform: rotateY(90deg) translateZ(300px); } .box:hover .bigright{ transform: rotateY(-90deg) translateZ(300px); } .box:hover .bigtop{ transform: rotateX(90deg) translateZ(300px); } .box:hover .bigbottom{ transform: rotateX(-90deg) translateZ(300px); } .box:hover .bigfront{ transform: rotateY(0deg) translateZ(300px); } .box:hover .bigback{ transform: translateZ(-300px) rotateY(180deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;bigbox&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;bigfront&quot;&gt; &lt;img src=&quot;image/1.jpg&quot; class=&quot;bigpic&quot; &gt; &lt;/div&gt; &lt;div class=&quot;bigback&quot;&gt; &lt;img src=&quot;image/2.jpg&quot; class=&quot;bigpic&quot;&gt; &lt;/div&gt; &lt;div class=&quot;bigleft&quot;&gt; &lt;img src=&quot;image/3.jpg&quot; class=&quot;bigpic&quot;&gt; &lt;/div&gt; &lt;div class=&quot;bigright&quot;&gt; &lt;img src=&quot;image/4.jpg&quot; class=&quot;bigpic&quot;&gt; &lt;/div&gt; &lt;div class=&quot;bigtop&quot;&gt; &lt;img src=&quot;image/5.jpg&quot; class=&quot;bigpic&quot;&gt; &lt;/div&gt; &lt;div class=&quot;bigbottom&quot;&gt; &lt;img src=&quot;image/6.jpg&quot; class=&quot;bigpic&quot;&gt; &lt;/div&gt; &lt;span class=&quot;smallfront&quot;&gt; &lt;img src=&quot;image/7.jpg&quot; class=&quot;smallpic&quot; /&gt; &lt;/span&gt; &lt;span class=&quot;smallback&quot;&gt; &lt;img src=&quot;image/8.jpg&quot; class=&quot;smallpic&quot; /&gt; &lt;/span&gt; &lt;span class=&quot;smallleft&quot;&gt; &lt;img src=&quot;image/9.jpg&quot; class=&quot;smallpic&quot; /&gt; &lt;/span&gt; &lt;span class=&quot;smallright&quot;&gt; &lt;img src=&quot;image/10.jpg&quot; class=&quot;smallpic&quot; /&gt; &lt;/span&gt; &lt;span class=&quot;smalltop&quot;&gt; &lt;img src=&quot;image/11.jpg&quot; class=&quot;smallpic&quot; /&gt; &lt;/span&gt; &lt;span class=&quot;smallbottom&quot;&gt; &lt;img src=&quot;image/12.jpg&quot; class=&quot;smallpic&quot; /&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;​","categories":[],"tags":[]},{"title":"Springboot ","slug":"Springboot ","date":"2021-02-23T06:35:33.271Z","updated":"2021-07-23T06:41:07.588Z","comments":true,"path":"2021/02/23/Springboot /","link":"","permalink":"https://codelin666.github.io/2021/02/23/Springboot%20/","excerpt":"","text":"SpringBootSpringBoot简介 Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。 第一阶段：xml配置 在Spring 1.x时代，使用Spring开发满眼都是xml配置的Bean，随着项目的扩大，我们需要把xml配置文件放到不同的配置文件里，那时需要频繁的在开发的类和配置文件之间进行切换 第二阶段：注解配置 Spring提供了声明Bean的注解（例如@Component、@Service），大大减少了配置量。 SPringBoot运行原理父依赖，其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ spring-boot-dependencies管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 启动器 spring-boot-starter SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；一个个starter就好似我们自己集成出来的一系列服务，可以自己选择开关。","categories":[],"tags":[]},{"title":"SpringMVC笔记 ","slug":"SpringMVC笔记 ","date":"2021-01-23T06:33:35.256Z","updated":"2021-07-23T06:10:36.677Z","comments":true,"path":"2021/01/23/SpringMVC笔记 /","link":"","permalink":"https://codelin666.github.io/2021/01/23/SpringMVC%E7%AC%94%E8%AE%B0%20/","excerpt":"","text":"一、SpringMVC简介1.什么是MVCModel：数据模型View：视图Controller：控制器 MVC是一种Web应用架构，是一种代码设计思想思想：将所有客户端请求交由控制器，由控制器将其进行分发，并将结果响应给客户端。 2.常见MVC框架使用原生Servlet实现MVC： 配置比较复杂 数据处理太麻烦实际开发中一般都会使用MVC框架，如Struts1、Struts2、SpringMVC等 对比： 效率方面，Struts1&gt;SpringMVC&gt;Struts2 Struts2是多例的，效率低 Struts1和SpringMVC是单例的，两者效率差不多。 配置方面：SpringMVC&gt;Struts2&gt;Struts13.为什么使用SpringMVC 使用注解来替代xml配置，更简单 是单例的，效率高 用户可以自定义，扩展性好 SpringMVC和Spring无缝衔接二、SpringMVC实现原理 DispatcherServletSpringMVC核心控制器(前端控制器)：主要是用来分发请求的 HandlerMapping映射处理器：根据请求的url来映射查找到对应的Handler Handler就是Controller层的实现类HandlerAdapter适配器：用来适配不同的处理器Handler处理器有两种实现方式：实现接口、基于注解，所以执行前需要先适配 Handler处理器：真正用来处理和执行业务，并产生数据模型Model和视图View，Handler会将Model和View封装成ModelAndView对象并返回。 ViewResolver视图解析器：根据视图名称解析成具体的视图，一般多为jsp页面，然后把它封装成View对象并返回。 三、RestFul 风格 RestFul 只是一种风格，基于这个风格设计的程序可以更简洁，有层次，更易于实现缓存等机制, 他实现了请求相同的路径而产生不同的逻辑的效果, 实现了 URL 复用 一般基于数据增删改查发出的请求，是通过==区分不同的路径==达到 CRUD 的效果，例如： localhost:8080/dropUser?id=1 删除用户 localhost:8080/finduser?id=1 查询用户而 RestFul 是通过==区分请求的方法==达到 CRUD 的效果，例如 localhost:8080/user?id=1 删除用户 发出DELETE请求 localhost:8080/user?id=1 查询用户 发出GET请求在 RestFul 中针对增删改查分别对应着四种请求方法 ［ 添加: POST ］［ 删除: DELETE ］［ 修改: PUT ］［ 查询: GET ］ 针对区分四种请求的方法有两种手段： 通过 RequestMapping 中的 method 属性进行区分请求 // 仅接收以post方法发出的请求 @RequestMapping(value=&quot;/user&quot;, method = RequestMethod.POST) 通过每个方法对应的注解进行区分 @PostMapping @DeleteMapping @PutMapping @GetMapping","categories":[],"tags":[]},{"title":"linux学习笔记","slug":"linux学习笔记","date":"2021-01-10T01:19:05.050Z","updated":"2021-01-09T12:31:36.242Z","comments":true,"path":"2021/01/10/linux学习笔记/","link":"","permalink":"https://codelin666.github.io/2021/01/10/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"preface：学习linux，主要依据了课堂知识and书籍and韩顺平 笔记主要依据韩顺平老师linux笔记所整理而成，如有侵权，请联系删除 在学习linux的路上，力推B站韩顺平的课程和鸟哥的linux私房菜这本书，真的帮助很大，可以帮助少走很多弯路。 需要资源（vmware，xshall，xftp，centos）的小伙伴可以加QQ私信我，很乐意分享，帮助一起学习。 Linux课程介绍1. 学习方向 linux运维工程师： 维护linux的服务器（一般大型企业） linux嵌入式工程师： linux做驱动开发，或者linux的嵌入式 linux下开发项目 2. 应用领域 个人桌面 服务器应用 免费，稳定，高效 侵入式应用 机顶盒，手机，数字电视，智能家居等 3. 学习进阶 学习基本指令 文件操作指令 编辑工具 用户管理 linux系统配置 环境变量，网络配置，服务配置 linux环境下搭建开发环境 大数据 JavaEE Python 等 编写shell脚本，对Linux服务器维护 安全设置，防止攻击，保证服务器正常运行，系统调优 深入理解Linux，对内核有研究，掌握大型网站架构、熟悉各环节部署方法Linux基本目录机构 1. 基本介绍 Linux的文件系统采用级层式子的树状目录结构， 最上层是根目录“/” Linux世界里，一切皆文件。 2. 目录用途 /bin： 是Binary的缩写，这个目录存放着最经常使用的命令。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /home：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc：所有的系统管理所需要的配置文件和子目录my.conf。 /usr/local：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。 /srv：service的缩写，该目录存放一些服务启动之后需要提供的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。 /tmp：这个目录是用来存放一些临时文件的。 /dev：类似windows的设备管理器，把所有的硬件用文件的形式存储。 /media：linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。 /opt：这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。 /var：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。 /selinux：SELinux是一种安全子系统，它能控制程序只能访问特定文件。 3. 总结 Linux的目录中有且只有一个根目录。 Linux的各个目录存放的内容是规划好，不用乱放文件。 Linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。 Linux的各个文件目录下存放什么内容，必须有一个认识。 远程登录Linux系统1. 远程登录方法1.1Xshell 可用Xshell等软件输入主机的IP地址，登录名链接 1.2ssh 链接指令 ssh -p 22 [登录用户]@[地址] 2. ftp文件传输 主要用于向服务上传或下载文件 vi和vim编辑器1. vi和vim的基本介绍 所有Linux系统都会内置vi文本编辑器 vim是vi的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。 2. vi和vim的三种模式2.1 正常模式 在正常模式下，我们可以使用快捷键。 用vim打开一个文件就直接进入一般模式 可以使用【删除字符】或【删除整行】来处理文档内容，也可以使用【复制黏贴按钮】 2.2 插入/编辑模式 在这个模式下，可以编辑文件内容。 按下i,I,o,O,a,A,r,R等字母就可进入编辑模式 2.3 命令行模式 在这个模式中，可以利用指令完成读取，存盘，替换，离开，显示行号的等动作。 wq保存退出 q无修改直接退出 q!不保存修改直接退出 3. Vim 的常见指令案例 yy：拷贝当前行 5yy：拷贝当前5行 dd：删除当前行 5dd：删除当前行向下的5行 在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个 设置文件行号：set nu，取消文件行号：set nonu 编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg 撤销输入：在正常模式下输入u 编辑文件，光标移动到某行：shift+g 显示行号：set nu 输入行号这个数 输入shift+g 4. vim其他常见指令补充4.1 文件命令 指令 说明 vim [file1 file2 file3 …] 打开单个或多个文件 :open file 在vim窗口中打开一个新文件 :split file 在新窗口中打开文件（split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。） Ctrl+ww 移动到下一个窗口 Ctrl+wj 移动到下方的窗口 Ctrl+wk 移动到上方的窗口 :close 最后一个窗口不能使用此命令，可以防止意外退出vim。 :only 关闭所有窗口，只保留当前窗口 :bn 切换到下一个文件 :bp 切换到上一个文件 :args 查看当前打开的文件列表，当前正在编辑的文件会用[]括起来 4.2 普通模式4.2.1 插入命令 指令 说明 i 在当前位置生前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 4.2.2 游标移动 指令 说明 gg 移动到文件头。 = [[ G（shift + g） 移动到文件尾。 = ]] 行數 → G 移動到第 n 行 冒号+行号，回车 比如跳到240行就是 :240回车 h 左移一个字符 l 右移一个字符，这个命令很少用，一般用w代替。 k 上移一个字符 j 下移一个字符 w 向前移动一个单词（光标停在单词首部） b 向后移动一个单词 2b 向后移动2个单词 e 同w，只不过是光标停在单词尾部 ge 同b，光标停在单词尾部。 ^ 移动到本行第一个非空白字符上。 0 移动到本行第一个字符上 HOME 移动到本行第一个字符。同0健。 $ 移动到行尾 3$ 移动到下面3行的行尾 f（find） fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。 F 同f，反向查找 4.2.3 撤销和重做 指令 说明 u 撤销（Undo） U 撤销对整行的操作 Ctrl + r 重做（Redo），即撤销的撤销。 4.2.4 删除命令 指令 说明 x 删除当前字符 3x 删除当前光标开始向后三个字符 X 删除当前字符的前一个字符。X=dh dl 删除当前字符， dl=x dh 删除前一个字符 dd 删除当前行 dj 删除上一行 dk 删除下一行 10d 删除当前行开始的10行。 D 删除当前字符至行尾。D=d$ d$ 删除当前字符之后的所有字符（本行） kdgg 删除当前行之前所有行（不包括当前行） jdG（jd shift + g） 删除当前行之后所有行（不包括当前行） :1,10d 删除1-10行 :11,$d 删除11行及以后所有的行 :1,$d 删除所有行 J(shift + j) 删除两行之间的空行，实际上是合并两行。 4.2.5 拷贝，剪贴和粘贴 指令 说明 yy 拷贝当前行 nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。 p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。 shift+p 在当前行前粘贴 :1,10 co 20 将1-10行插入到第20行之后。 :1,$ co $ 将整个文件复制一份并添加到文件尾部。 ddp 交换当前行和其下一行 xp 交换当前字符和其后一个字符 ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴 :1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。 :1, 10 m 20 将第1-10行移动到第20行之后。 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制 4.2.6 退出命令 指令 说明 :wq 保存并退出 ZZ 保存并退出 :q! 强制退出并忽略所有更改 :e! 放弃所有修改，并打开原来文件。 :q 未修改直接退出 4.2.7 注释命令perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入# 指令 说明 3,5 s/^/#/g 注释第3-5行 3,5 s/^#//g 解除3-5行的注释 1,$ s/^/#/g 注释整个文档。 :%s/^/#/g 注释整个文档，此法更快。 4.3 执行shell命令 :!command 指令 说明 :!ls 列出当前目录下文件 :!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。 :!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。 :suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。 4.4 帮助命令 指令 说明 :help or F1 显示整个帮助 :help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。 :help ‘number’ Vim选项的帮助用单引号括起 :help &lt;Esc&gt; 特殊键的帮助用&lt;&gt;扩起 :help -t Vim启动参数的帮助用- ：help i_&lt;Esc&gt; 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式 帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回 4.5 其他非编辑命令 指令 说明 . 重复前一次命令 :set ruler? 查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看 :scriptnames 查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。 :set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了 expandtab，那么tab将被扩展为空格。 Vim教程 在Unix系统上 $ vimtutor 在Windows系统上 :help tutor 录制宏: 按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。 :syntax 列出已经定义的语法项 :syntax clear 清除已定义的语法规则 :syntax case match 大小写敏感，int和Int将视为不同的语法元素 :syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案 关机、重启和用户登录注销1. 关机&amp;重启命令1.1 shutdown shutdown -h now：表示立即关机 shutdown -h 1：表示1分钟后关机 shutdown -r now：立即重启 1.2 halt halt：直接使用，关机 1.3 reboot reboot 重启系统 1.4 sync sync：把内存的数据同步到磁盘上 当我们关机或者重启时，都应该先执行一下sync，防止数据丢失。 2. 用户登录注销 登录时少用root账号登录，以避免操作失误的损失 平时可登录普通账户，再用“su - 用户名”切换成管理员登录 2.1 logout logout：注销用户 在图形运行级别无效，在运行级别3有效。 用户管理1. 基本用户管理 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 1.1 添加用户 添加用户：useradd [选项] 用户名。 1.1.1 参数说明 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 -f [缓冲天数] 指定在密码过期后多少天即关闭该帐号。 -e 有效期限 指定帐号的有效期限； -M：不要自动建立用户的登入目录； 用户名: 指定新账号的登录名。 1.1.2 实例 useradd –d /home/sam -m sam 此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。 useradd -s /bin/sh -g group –G adm,root gem 新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。 1.2 用户口令的管理 指定和修改用户口令: passwd 选项 用户名 1.2.1 参数说明 选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 1.2.2 注意事项 如果默认用户名，则修改当前用户的口令。 假设当前用户是sam，则下面的命令修改该用户自己的口令：passwd sam 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户； 超级用户为用户指定口令时，就不需要知道原口令。 1.2.3 案例 passwd -l sam 用 -l(lock) 选项锁定某一用户，使其不能登录 passwd -d sam 为用户指定空口令 1.3 删除帐号 删除帐号: userdel 选项 用户名 1.3.1 注意事项 常用的选项是 -r，它的作用是把用户的主目录一起删除。 userdel -r sam 1.4 修改帐号 修改已有用户的信息: usermod 选项 用户名 1.4.1 注意事项 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 1.5 查询用户信息 查询用户信息: id 用户名 用户不存在是返回“无此用户” 查看当前用户/登录用户：who am i 1.6 切换用户 切换用户：su - 切换用户名 从权限高切换到权限低的用户不需要输密码。 返回切换前的用户：exit 2. 用户组的管理 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 2.1 增加一个新的用户组 增加一个新的用户组: groupadd 选项 用户组 2.1.1 说明 选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 2.1.2 案例 groupadd -g 101 group2 向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 groupadd -g 101 group2 向系统中增加了一个新组group2，同时指定新组的组标识号是101。 2.2 删除用户组 删除用户组: groupmod 选项 用户组 2.1.2 说明 选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 2.1.3 案例 groupmod -g 102 group2 将组group2的组标识号修改为102。 groupmod –g 10000 -n group3 group2 将组group2的标识号改为10000，组名修改为group3。 2.3 组的切换 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： $ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。 3. 与用户账号有关的系统文件3.1 /etc/passwd 文件 用户（user）的配置文件，记录用户的各种信息。 每行的含义： “用户名”是代表用户账号的字符串。 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 “口令”一些系统中，存放着加密后的用户口令字。 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 “用户标识号”是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 “组标识号”字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 “注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。 “主目录”，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 3.2 /etc/shadow 文件 口令配置文件 每行的含义： “登录名”是与/etc/passwd文件中的登录名相一致的用户账号 “口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 “最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 “最小时间间隔”指的是两次修改口令之间所需的最小天数。 “最大时间间隔”指的是口令保持有效的最大天数。 “警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 “不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。 “失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 3.3 /etc/group 文件 组（group）的配置文件，用户组的所有信息都存放在/etc/group文件中。 每行含义： “组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 “口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 “组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。 “组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 实用指令1. 指定运行级别（7个级别） 0.关机 1.单用户【找回丢失密码】 2.多用户状态没有网络服务 3.多用户状态有网络服务 4.系统未使用保留给用户 5.图形界面 6.系统重启 系统的运行级别配置文件：/etc/inittab 切换到指定运行级别的指令：init [012356] 2. 帮助指令2.1 man获得帮助信息 man [命令或配置文件] 例如:man ls 2.2 help指令 help [命令或配置文件] 3. 文件目录类指令3.1 文件剪贴删除复制重名等 pwd：Print Working Directory，显示当前工作目录的绝对路径。 ls：-a：显示当前目录所有的文件和目录，包括隐藏的； -l：以列表的方式显示信息。 cd：cd ~：回到自己的家目录；cd …：回到当前目录的上一级目录。 mkdir：创建目录；-p：创建多级目录。 rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。 cp：拷贝文件到指定目录； -r：递归复制整个文件夹。强制覆盖不提示的方法： cp命令改为\\cp rm：移除文件或目录； -r：递归删除整个文件夹； -f：强制删除不提示。 mv：移动文件与目录或重命名，两种功能！ touch：创建空文件。可以一次性创建多个文件 ln 给文件创建一个软连接 用法:ln -s[源文件或目录][软连接名] 3.2 文件查看 cat：查看文件内容。只能浏览文件，而不能修改文件。 -n：显示行号。 结尾加上 | more：分页显示，不会全部一下显示完。 more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键： 空白键（Space）：向下翻一页 Enter：向下翻一行 q：立刻离开more，不再显示该文件内容 Ctrl + F：向下滚动一屏 Ctrl + B：返回上一屏 = :输出当前行的行号 :f 输出文件名和当前行的行号 less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。 head：显示文件的开头部分。-n 5：看前面5行内容。 tail：输出文件中尾部的内容。 -n 5：看后面5行内容。 -f：时事追踪该文档的所有更新 &gt;指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。 &gt;&gt;指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。 echo：输出内容到控制台。 history：查看历史指令 3.3 时间和日期 date：显示当前日期和时间 date “+%Y”：显示当前年份 date “+%d”：显示当前月份 date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒 设置日期：date -s 字符串时间 cal：查看日历指令； cal [月] [年份]：显示某一年或月的日历 3.4 搜索查找类 find：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。 find (搜索范围) -name (文件名)：按照指定的文件名查找模式查找文件。 find (搜索范围) -user (用户名)：按照指定的用户名查找模式查找文件。 find (搜索范围) -size (+多少/-多少/多少)：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少） 查询 /目录下所有.txt的文件：find / -name *.txt locate：locate (搜索文件) 可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。 locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。 在第一次运行之前，必须使用updatedb指令创建locate数据库。 grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。 grep [选项] 查找内容 源文件 -n：显示匹配行及行号。 -i：忽略大小写字母。 cat hello.txt | grep yes 3.5 压缩和解压类 gzip/gunzip：压缩文件/解压 gzip (文件)：压缩为.gz文件，原来文件不保留。 gunzip (文件)：解压缩，同样也不保留源文件。 zip/unzip：压缩文件/解压 zip [选项] (压缩后文件xxx.zip) (将要压缩的文件) unzip [选项] (要解压的文件xxx.zip) zip -r：递归压缩，即压缩目录 unzip -d (目录)：指定解压后的文件的存放目录 tar：打包指令，最后打包后的文件是.tar.gz的文件 tar [选项] xxx.tar.gz (打包的内容) -c：产生.tar打包文件 -v：显示详细信息 -f：指定压缩后的文件名 -z：打包同时压缩 -x：解压.tar文件 压缩：tar -zcvf (压缩后文件名) (要压缩的文件) 解压：tar -zxvf (要解压的文件) 解压到指定目录：tar -zxvf (要解压的文件) -C (指定目录)，指定解压到的目录要存在。 组管理和权限管理1. Linux组基本介绍 Linux中每个用户属于一个组，不能独立于组以外。所以在Linux中每个文件存在组的概念： 所有者 所在组 其他组 改变用户所在组 2. 文件/目录所有者 一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。 查看文件所有者：ls -ahl 修改文件所有者：chown (用户名) (文件名) 3. 文件/目录所在组 当某个用户创建了一个文件之后，默认之歌文件所在组就是该用户所在的组 查看文件所有者：ls -ahl 修改文件所在组：chgrp (组名) (文件名) 4. 其他组 除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组 5. 文件属性 ls -l中显示的内容如图所示 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。每个文件的属性由左边第一部分的10个字符来确定（如下图）。 5.1 rwx权限详解 rwx作用到文件： r：read，可读。读取查看。 w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。 x：execute，可执行。可以被执行。 rwx作用到目录： r：可以读取，ls查看目录内容。 w：可以修改，目录内创建+删除+重命名目录。 x：可执行，可以进入该目录。 5.2 修改权限5.2.1 chgrp：更改文件属组 chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 5.2.2 chown：更改文件属主，也可以同时更改文件属组 语法: chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 5.2.3 chmod：更改文件9个属性 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 5.2.3.1 使用数字修改权限 chmod [-R] xyz 文件或目录 xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 5.2.3.1 使用符号修改权限 我们就可以使用 u(user), g(group), o(others) 来代表三种身份的权限！ 此外， a 则代表 all，即全部的身份。 3.7定时任务调度 定时任务调度1. 任务调度原理 crond任务调度：crontab进行定时任务调度 使用方法：crontab [选项] crontab [选项] -e：编辑crontab定时任务 -i：查询crontab任务 -r：删除当前用户所有的crontab任务 -l：列出当前有哪些任务调度 service crond restart：重启任务调度 当保存退出后就生效了 参数细节说明 项目 含义 范围 第一个“*” 一小时当中的第几分钟 0-59 第二个“*” 一天当中的第几小时 0-23 第三个“*” 一个月当中的第几天 1-31 第四个“*” 一年当中的第几月 1-12 第五个“*” 一周当中的星期几 0-7（0和7都代表星期日） 特殊符号说明 \\*：代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思。 ,：代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。 -：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。 /n：代表每隔多久执行一次。比如“/10 \\ * * * 命令”，代表每隔10分钟就执行一遍命令。 包管理工具1. RPM包 RPM：RedHat Package Manager，红帽软件包管理工具。Linuxd分发版本都有采用（suse,redhat，centos等） 1.1 rpm指令1.1.1 查看指令 RPM查询已安装的rpm列表：rpm -qa | grep xx 查看是否安装firefox：rpm -qa |grep firefox 如果是i686,i386表示32位系统，noarch表示通用 rpm -qa：查询所安装的所有rpm软件包 rpm -qa | more rpm -qa | grep xx rpm -q xx：查询xx软件包是否安装 rpm -qi xx：查询软件包信息 rpm -ql xx：查询软件包中的文件 rpm -qf 文件全路径名：查询文件所属的软件包 1.1.2 卸载指令 卸载rpm包：rpm -e 软件包名称 如果其他软件依赖于要卸载的包，删除时可能会发生依赖错误 忽视依赖强制删除的方法：rpm -e –nodeps 软件包名称 可以强制删除，但不建议这样做，否则会导致程序无法运行 1.1.3安装指令 安装rpm包：rpm -ivh 软件包全路径名称 i=install：安装 v=verbose：提示 h=hash：进度条 2. YUM yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum list | grep xx：查询yum服务器是否有需要安装的软件 yum install xx：安装指定的yum包 yum -y remove xx：卸载指定的yum包","categories":[],"tags":[]},{"title":"设计模式七大原则","slug":"设计模式七大原则","date":"2020-11-11T07:40:49.760Z","updated":"2020-11-11T07:40:49.841Z","comments":true,"path":"2020/11/11/设计模式七大原则/","link":"","permalink":"https://codelin666.github.io/2020/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"设计模式七大原则设计模式常用的七大原则有: 单一职责原则 接口隔离原则 依赖倒转(倒置)原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 单一职责原则​ 对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2 单一职责原则注意事项和细节 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则 接口隔离原则​ 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 接口隔离原则注意事项和细节接口 Interface 中出现的方法，根据实际情况拆分为三个接口然后不同的类去继承多个小的接口，实现接口的隔离。 依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 依赖倒转(倒置)的中心思想是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 依赖关系传递的三种方式 接口传递 构造方法传递应用案例代码 setter 方式传递 依赖倒转原则的注意事项和细节 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好. 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化 继承时遵循里氏替换原则 里氏替换原则 如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。 里氏替换通用方法原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替. 开闭原则 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。 迪米特法则 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息 迪米特法则还有个更简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。 迪米特法则注意事项 迪米特法则的核心是降低类之间的耦合 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系 合成复用原则原则是尽量使用合成/聚合的方式，而不是使用继承 设计模式的核心思想是 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计而努力","categories":[],"tags":[]},{"title":"mybatis中使用逆向工程","slug":"mybatis中使用逆向工程","date":"2020-11-11T06:58:57.000Z","updated":"2020-11-11T07:11:59.971Z","comments":true,"path":"2020/11/11/mybatis中使用逆向工程/","link":"","permalink":"https://codelin666.github.io/2020/11/11/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"mybatis中使用逆向工程 首先导入maven 12345678910111213141516171819202122232425&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.7&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;configurationFile&gt; src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml &lt;&#x2F;configurationFile&gt; &lt;&#x2F;configuration&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis.generator&#x2F;mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.15&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt; 建立generatorconfig.xml，然后输入以下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id&#x3D;&quot;testTables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;employee?serverTimezone&#x3D;UTC&quot; userId&#x3D;&quot;root&quot; password&#x3D;&quot;0606&quot;&gt; &lt;property name&#x3D;&quot;nullCatalogMeansCurrent&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;com.generatodemo.my01.demo.pojo&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.mapper&quot; targetProject&#x3D;&quot;.\\src\\main\\resources&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.generatodemo.my01.demo.pojo.mapper&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;!-- &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;tb_item&quot; domainObjectName&#x3D;&quot;Item&quot;&gt;&lt;&#x2F;table&gt; domainObjectName 可以配置生成的pojo名字 如不需要example类添加下面四个属性 enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt;--&gt; &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;employee&quot; domainObjectName&#x3D;&quot;employee&quot; enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt; &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;department&quot; domainObjectName&#x3D;&quot;department&quot; enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; 最后点击","categories":[],"tags":[]},{"title":"JAVA中实现Singleton模式","slug":"JAVA中实现Singleton模式","date":"2020-07-19T06:42:00.084Z","updated":"2020-07-19T06:41:43.119Z","comments":true,"path":"2020/07/19/JAVA中实现Singleton模式/","link":"","permalink":"https://codelin666.github.io/2020/07/19/JAVA%E4%B8%AD%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JAVA中实现Singleton模式单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 单例模式写法双重检查Double-Checkpublic class Singleton { private static volatile Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }volatile关键字千万不能掉，禁止指令重排序优化 静态内部类public class Singleton { private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } }这种方式跟饿汉式方式采用的机制类似，但是可以延迟加载，并且线程安全，推荐使用。类的静态属性只会在第一次加载的时候被初始化，所以这是从JVM底层上保证了线程的安全性。 枚举public enum Singleton { INSTANCE; public void whateverMethod() { } }JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 单例模式的优缺点优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 缺点 单例模式一般没有接口，扩展很困难","categories":[],"tags":[]}],"categories":[],"tags":[]}