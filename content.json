{"meta":{"title":"晓琳","subtitle":"","description":"","author":"晓琳","url":"https://codelin666.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-07-12T06:49:27.000Z","updated":"2020-07-12T07:01:03.361Z","comments":true,"path":"tags/index.html","permalink":"https://codelin666.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式七大原则","slug":"设计模式七大原则","date":"2020-11-11T07:40:49.760Z","updated":"2020-11-11T07:40:49.841Z","comments":true,"path":"2020/11/11/设计模式七大原则/","link":"","permalink":"https://codelin666.github.io/2020/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"设计模式七大原则设计模式常用的七大原则有: 单一职责原则 接口隔离原则 依赖倒转(倒置)原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 单一职责原则​ 对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2 单一职责原则注意事项和细节 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则 接口隔离原则​ 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 接口隔离原则注意事项和细节接口 Interface 中出现的方法，根据实际情况拆分为三个接口然后不同的类去继承多个小的接口，实现接口的隔离。 依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 依赖倒转(倒置)的中心思想是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 依赖关系传递的三种方式 接口传递 构造方法传递应用案例代码 setter 方式传递 依赖倒转原则的注意事项和细节 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好. 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化 继承时遵循里氏替换原则 里氏替换原则 如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。 里氏替换通用方法原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替. 开闭原则 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。 迪米特法则 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息 迪米特法则还有个更简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。 迪米特法则注意事项 迪米特法则的核心是降低类之间的耦合 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系 合成复用原则原则是尽量使用合成/聚合的方式，而不是使用继承 设计模式的核心思想是 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计而努力","categories":[],"tags":[]},{"title":"mybatis中使用逆向工程","slug":"mybatis中使用逆向工程","date":"2020-11-11T06:58:57.000Z","updated":"2020-11-11T07:11:59.971Z","comments":true,"path":"2020/11/11/mybatis中使用逆向工程/","link":"","permalink":"https://codelin666.github.io/2020/11/11/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"mybatis中使用逆向工程 首先导入maven 12345678910111213141516171819202122232425&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.7&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;configurationFile&gt; src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml &lt;&#x2F;configurationFile&gt; &lt;&#x2F;configuration&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis.generator&#x2F;mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.15&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt; 建立generatorconfig.xml，然后输入以下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id&#x3D;&quot;testTables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;employee?serverTimezone&#x3D;UTC&quot; userId&#x3D;&quot;root&quot; password&#x3D;&quot;0606&quot;&gt; &lt;property name&#x3D;&quot;nullCatalogMeansCurrent&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;com.generatodemo.my01.demo.pojo&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.mapper&quot; targetProject&#x3D;&quot;.\\src\\main\\resources&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.generatodemo.my01.demo.pojo.mapper&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;!-- &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;tb_item&quot; domainObjectName&#x3D;&quot;Item&quot;&gt;&lt;&#x2F;table&gt; domainObjectName 可以配置生成的pojo名字 如不需要example类添加下面四个属性 enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt;--&gt; &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;employee&quot; domainObjectName&#x3D;&quot;employee&quot; enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt; &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;department&quot; domainObjectName&#x3D;&quot;department&quot; enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; 最后点击","categories":[],"tags":[]},{"title":"JAVA中实现Singleton模式","slug":"JAVA中实现Singleton模式","date":"2020-07-19T06:42:00.084Z","updated":"2020-07-19T06:41:43.119Z","comments":true,"path":"2020/07/19/JAVA中实现Singleton模式/","link":"","permalink":"https://codelin666.github.io/2020/07/19/JAVA%E4%B8%AD%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JAVA中实现Singleton模式单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 单例模式写法双重检查Double-Checkpublic class Singleton { private static volatile Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }volatile关键字千万不能掉，禁止指令重排序优化 静态内部类public class Singleton { private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } }这种方式跟饿汉式方式采用的机制类似，但是可以延迟加载，并且线程安全，推荐使用。类的静态属性只会在第一次加载的时候被初始化，所以这是从JVM底层上保证了线程的安全性。 枚举public enum Singleton { INSTANCE; public void whateverMethod() { } }JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 单例模式的优缺点优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 缺点 单例模式一般没有接口，扩展很困难","categories":[],"tags":[]}],"categories":[],"tags":[]}