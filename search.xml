<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA中实现Singleton模式</title>
    <url>/2020/07/19/JAVA%E4%B8%AD%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h2 id="JAVA中实现Singleton模式"><a href="#JAVA中实现Singleton模式" class="headerlink" title="JAVA中实现Singleton模式"></a>JAVA中实现Singleton模式</h2><p>单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</p>
<h2 id="单例模式写法"><a href="#单例模式写法" class="headerlink" title="单例模式写法"></a>单例模式写法</h2><h3 id="双重检查Double-Check"><a href="#双重检查Double-Check" class="headerlink" title="双重检查Double-Check"></a>双重检查Double-Check</h3><pre><code>public class Singleton {
private static volatile Singleton singleton;
private Singleton() {}
public static Singleton getInstance() {
    if (singleton == null) {
        synchronized (Singleton.class) {
            if (singleton == null) {
                singleton = new Singleton();
            }
        }
    }
    return singleton;
    }
    }</code></pre><p>volatile关键字千万不能掉，禁止指令重排序优化</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code>public class Singleton {

private Singleton() {}

private static class SingletonInstance {
    private static final Singleton INSTANCE = new Singleton();
}

public static Singleton getInstance() {
    return SingletonInstance.INSTANCE;
}
}</code></pre><p>这种方式跟饿汉式方式采用的机制类似，但是可以延迟加载，并且线程安全，推荐使用。类的静态属性只会在第一次加载的时候被初始化，所以这是从JVM底层上保证了线程的安全性。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code>public enum Singleton {
INSTANCE;
public void whateverMethod() {
}
}</code></pre><p>JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>
<h3 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p> 单例模式一般没有接口，扩展很困难</p>
]]></content>
  </entry>
  <entry>
    <title>linux学习笔记</title>
    <url>/2021/01/10/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>preface：学习linux，主要依据了课堂知识and书籍and韩顺平</p>
<p>笔记主要依据韩顺平老师linux笔记所整理而成，如有侵权，请联系删除</p>
<p>在学习linux的路上，力推B站韩顺平的课程和鸟哥的linux私房菜这本书，真的帮助很大，可以帮助少走很多弯路。</p>
<p>需要资源（vmware，xshall，xftp，centos）的小伙伴可以加QQ私信我，很乐意分享，帮助一起学习。</p>
<h1 id="Linux课程介绍"><a href="#Linux课程介绍" class="headerlink" title="Linux课程介绍"></a>Linux课程介绍</h1><h2 id="1-学习方向"><a href="#1-学习方向" class="headerlink" title="1. 学习方向"></a>1. 学习方向</h2><ul>
<li>linux运维工程师： 维护linux的服务器（一般大型企业）</li>
<li>linux嵌入式工程师： linux做驱动开发，或者linux的嵌入式</li>
<li>linux下开发项目</li>
</ul>
<h2 id="2-应用领域"><a href="#2-应用领域" class="headerlink" title="2. 应用领域"></a>2. 应用领域</h2><ul>
<li>个人桌面</li>
<li>服务器应用<ul>
<li>免费，稳定，高效</li>
</ul>
</li>
<li>侵入式应用<ul>
<li>机顶盒，手机，数字电视，智能家居等</li>
</ul>
</li>
</ul>
<h2 id="3-学习进阶"><a href="#3-学习进阶" class="headerlink" title="3. 学习进阶"></a>3. 学习进阶</h2><ol>
<li>学习基本指令<ul>
<li>文件操作指令</li>
<li>编辑工具</li>
<li>用户管理</li>
</ul>
</li>
<li>linux系统配置<ul>
<li>环境变量，网络配置，服务配置</li>
</ul>
</li>
<li>linux环境下搭建开发环境<ul>
<li>大数据 JavaEE Python 等</li>
</ul>
</li>
<li>编写shell脚本，对Linux服务器维护</li>
<li>安全设置，防止攻击，保证服务器正常运行，系统调优</li>
<li>深入理解Linux，对内核有研究，掌握大型网站架构、熟悉各环节部署方法<h1 id="Linux基本目录机构"><a href="#Linux基本目录机构" class="headerlink" title="Linux基本目录机构"></a>Linux基本目录机构</h1></li>
</ol>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul>
<li>Linux的文件系统采用级层式子的树状目录结构，</li>
<li>最上层是根目录“/”</li>
<li><strong>Linux世界里，一切皆文件。</strong></li>
</ul>
<h2 id="2-目录用途"><a href="#2-目录用途" class="headerlink" title="2. 目录用途"></a>2. 目录用途</h2><ul>
<li><code>/bin：</code> 是Binary的缩写，这个目录存放着最经常使用的命令。</li>
<li>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><code>/home：</code>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><code>/root：</code>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li>/lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li>/etc：所有的系统管理所需要的配置文件和子目录my.conf。</li>
<li><code>/usr/local</code>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</li>
<li><code>/boot：</code>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</li>
<li>/srv：service的缩写，该目录存放一些服务启动之后需要提供的数据。</li>
<li>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。</li>
<li>/tmp：这个目录是用来存放一些临时文件的。</li>
<li>/dev：类似windows的设备管理器，把所有的硬件用文件的形式存储。</li>
<li><code>/media：</code>linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><code>/mnt：</code>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</li>
<li><code>/opt：</code>这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</li>
<li>/usr/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</li>
<li><code>/var：</code>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li>
<li>/selinux：SELinux是一种安全子系统，它能控制程序只能访问特定文件。</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol>
<li>Linux的目录中有且只有一个根目录。</li>
<li>Linux的各个目录存放的内容是规划好，不用乱放文件。</li>
<li>Linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。</li>
<li>Linux的各个文件目录下存放什么内容，必须有一个认识。</li>
</ol>
<h1 id="远程登录Linux系统"><a href="#远程登录Linux系统" class="headerlink" title="远程登录Linux系统"></a>远程登录Linux系统</h1><h2 id="1-远程登录方法"><a href="#1-远程登录方法" class="headerlink" title="1. 远程登录方法"></a>1. 远程登录方法</h2><h3 id="1-1Xshell"><a href="#1-1Xshell" class="headerlink" title="1.1Xshell"></a>1.1Xshell</h3><ul>
<li>可用Xshell等软件输入主机的IP地址，登录名链接</li>
</ul>
<h3 id="1-2ssh"><a href="#1-2ssh" class="headerlink" title="1.2ssh"></a>1.2ssh</h3><ul>
<li>链接指令 ssh -p 22 [登录用户]@[地址]</li>
</ul>
<h2 id="2-ftp文件传输"><a href="#2-ftp文件传输" class="headerlink" title="2. ftp文件传输"></a>2. ftp文件传输</h2><ul>
<li>主要用于向服务上传或下载文件</li>
</ul>
<h1 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h1><h2 id="1-vi和vim的基本介绍"><a href="#1-vi和vim的基本介绍" class="headerlink" title="1. vi和vim的基本介绍"></a>1. vi和vim的基本介绍</h2><ul>
<li>所有Linux系统都会内置vi文本编辑器</li>
<li>vim是vi的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。</li>
</ul>
<h2 id="2-vi和vim的三种模式"><a href="#2-vi和vim的三种模式" class="headerlink" title="2. vi和vim的三种模式"></a>2. vi和vim的三种模式</h2><h3 id="2-1-正常模式"><a href="#2-1-正常模式" class="headerlink" title="2.1 正常模式"></a>2.1 正常模式</h3><ul>
<li>在正常模式下，我们可以使用快捷键。</li>
<li>用vim打开一个文件就直接进入一般模式</li>
<li>可以使用【删除字符】或【删除整行】来处理文档内容，也可以使用【复制黏贴按钮】</li>
</ul>
<h3 id="2-2-插入-编辑模式"><a href="#2-2-插入-编辑模式" class="headerlink" title="2.2 插入/编辑模式"></a>2.2 插入/编辑模式</h3><ul>
<li>在这个模式下，可以编辑文件内容。</li>
<li>按下i,I,o,O,a,A,r,R等字母就可进入编辑模式</li>
</ul>
<h3 id="2-3-命令行模式"><a href="#2-3-命令行模式" class="headerlink" title="2.3 命令行模式"></a>2.3 命令行模式</h3><ul>
<li>在这个模式中，可以利用指令完成读取，存盘，替换，离开，显示行号的等动作。</li>
<li>wq保存退出</li>
<li>q无修改直接退出</li>
<li>q!不保存修改直接退出</li>
</ul>
<h2 id="3-Vim-的常见指令案例"><a href="#3-Vim-的常见指令案例" class="headerlink" title="3. Vim 的常见指令案例"></a>3. Vim 的常见指令案例</h2><ol>
<li>yy：拷贝当前行</li>
<li>5yy：拷贝当前5行</li>
<li>dd：删除当前行</li>
<li>5dd：删除当前行向下的5行</li>
<li>在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个</li>
<li>设置文件行号：set nu，取消文件行号：set nonu</li>
<li>编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg</li>
<li>撤销输入：在正常模式下输入u</li>
<li>编辑文件，光标移动到某行：shift+g<ul>
<li>显示行号：set nu</li>
<li>输入行号这个数</li>
<li>输入shift+g</li>
</ul>
</li>
</ol>
<h2 id="4-vim其他常见指令补充"><a href="#4-vim其他常见指令补充" class="headerlink" title="4. vim其他常见指令补充"></a>4. vim其他常见指令补充</h2><h3 id="4-1-文件命令"><a href="#4-1-文件命令" class="headerlink" title="4.1 文件命令"></a>4.1 文件命令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vim [file1 file2 file3 …]</td>
<td>打开单个或多个文件</td>
</tr>
<tr>
<td>:open file</td>
<td>在vim窗口中打开一个新文件</td>
</tr>
<tr>
<td>:split file</td>
<td>在新窗口中打开文件（split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。）</td>
</tr>
<tr>
<td>Ctrl+ww</td>
<td>移动到下一个窗口</td>
</tr>
<tr>
<td>Ctrl+wj</td>
<td>移动到下方的窗口</td>
</tr>
<tr>
<td>Ctrl+wk</td>
<td>移动到上方的窗口</td>
</tr>
<tr>
<td>:close</td>
<td>最后一个窗口不能使用此命令，可以防止意外退出vim。</td>
</tr>
<tr>
<td>:only</td>
<td>关闭所有窗口，只保留当前窗口</td>
</tr>
<tr>
<td>:bn</td>
<td>切换到下一个文件</td>
</tr>
<tr>
<td>:bp</td>
<td>切换到上一个文件</td>
</tr>
<tr>
<td>:args</td>
<td>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来</td>
</tr>
</tbody></table>
<h3 id="4-2-普通模式"><a href="#4-2-普通模式" class="headerlink" title="4.2 普通模式"></a>4.2 普通模式</h3><h4 id="4-2-1-插入命令"><a href="#4-2-1-插入命令" class="headerlink" title="4.2.1 插入命令"></a>4.2.1 插入命令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在当前位置生前插入</td>
</tr>
<tr>
<td>I</td>
<td>在当前行首插入</td>
</tr>
<tr>
<td>a</td>
<td>在当前位置后插入</td>
</tr>
<tr>
<td>A</td>
<td>在当前行尾插入</td>
</tr>
<tr>
<td>o</td>
<td>在当前行之后插入一行</td>
</tr>
<tr>
<td>O</td>
<td>在当前行之前插入一行</td>
</tr>
</tbody></table>
<h4 id="4-2-2-游标移动"><a href="#4-2-2-游标移动" class="headerlink" title="4.2.2 游标移动"></a>4.2.2 游标移动</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>移动到文件头。 = [[</td>
</tr>
<tr>
<td>G（shift + g）</td>
<td>移动到文件尾。 = ]]</td>
</tr>
<tr>
<td>行數 → G</td>
<td>移動到第 n 行</td>
</tr>
<tr>
<td>冒号+行号，回车</td>
<td>比如跳到240行就是 :240回车</td>
</tr>
<tr>
<td>h</td>
<td>左移一个字符</td>
</tr>
<tr>
<td>l</td>
<td>右移一个字符，这个命令很少用，一般用w代替。</td>
</tr>
<tr>
<td>k</td>
<td>上移一个字符</td>
</tr>
<tr>
<td>j</td>
<td>下移一个字符</td>
</tr>
<tr>
<td>w</td>
<td>向前移动一个单词（光标停在单词首部）</td>
</tr>
<tr>
<td>b</td>
<td>向后移动一个单词 2b 向后移动2个单词</td>
</tr>
<tr>
<td>e</td>
<td>同w，只不过是光标停在单词尾部</td>
</tr>
<tr>
<td>ge</td>
<td>同b，光标停在单词尾部。</td>
</tr>
<tr>
<td>^</td>
<td>移动到本行第一个非空白字符上。</td>
</tr>
<tr>
<td>0</td>
<td>移动到本行第一个字符上</td>
</tr>
<tr>
<td>HOME</td>
<td>移动到本行第一个字符。同0健。</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾 3$ 移动到下面3行的行尾</td>
</tr>
<tr>
<td>f（find）</td>
<td>fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td>
</tr>
<tr>
<td>F</td>
<td>同f，反向查找</td>
</tr>
</tbody></table>
<h4 id="4-2-3-撤销和重做"><a href="#4-2-3-撤销和重做" class="headerlink" title="4.2.3 撤销和重做"></a>4.2.3 撤销和重做</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>撤销（Undo）</td>
</tr>
<tr>
<td>U</td>
<td>撤销对整行的操作</td>
</tr>
<tr>
<td>Ctrl + r</td>
<td>重做（Redo），即撤销的撤销。</td>
</tr>
</tbody></table>
<h4 id="4-2-4-删除命令"><a href="#4-2-4-删除命令" class="headerlink" title="4.2.4 删除命令"></a>4.2.4 删除命令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除当前字符</td>
</tr>
<tr>
<td>3x</td>
<td>删除当前光标开始向后三个字符</td>
</tr>
<tr>
<td>X</td>
<td>删除当前字符的前一个字符。X=dh</td>
</tr>
<tr>
<td>dl</td>
<td>删除当前字符， dl=x</td>
</tr>
<tr>
<td>dh</td>
<td>删除前一个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>dj</td>
<td>删除上一行</td>
</tr>
<tr>
<td>dk</td>
<td>删除下一行</td>
</tr>
<tr>
<td>10d</td>
<td>删除当前行开始的10行。</td>
</tr>
<tr>
<td>D</td>
<td>删除当前字符至行尾。D=d$</td>
</tr>
<tr>
<td>d$</td>
<td>删除当前字符之后的所有字符（本行）</td>
</tr>
<tr>
<td>kdgg</td>
<td>删除当前行之前所有行（不包括当前行）</td>
</tr>
<tr>
<td>jdG（jd shift + g）</td>
<td>删除当前行之后所有行（不包括当前行）</td>
</tr>
<tr>
<td>:1,10d</td>
<td>删除1-10行</td>
</tr>
<tr>
<td>:11,$d</td>
<td>删除11行及以后所有的行</td>
</tr>
<tr>
<td>:1,$d</td>
<td>删除所有行</td>
</tr>
<tr>
<td>J(shift + j)</td>
<td>删除两行之间的空行，实际上是合并两行。</td>
</tr>
</tbody></table>
<h4 id="4-2-5-拷贝，剪贴和粘贴"><a href="#4-2-5-拷贝，剪贴和粘贴" class="headerlink" title="4.2.5 拷贝，剪贴和粘贴"></a>4.2.5 拷贝，剪贴和粘贴</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>拷贝当前行</td>
</tr>
<tr>
<td>nyy</td>
<td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td>
</tr>
<tr>
<td>p</td>
<td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td>
</tr>
<tr>
<td>shift+p</td>
<td>在当前行前粘贴</td>
</tr>
<tr>
<td>:1,10 co 20</td>
<td>将1-10行插入到第20行之后。</td>
</tr>
<tr>
<td>:1,$ co $</td>
<td>将整个文件复制一份并添加到文件尾部。</td>
</tr>
<tr>
<td>ddp</td>
<td>交换当前行和其下一行</td>
</tr>
<tr>
<td>xp</td>
<td>交换当前字符和其后一个字符</td>
</tr>
<tr>
<td>ndd</td>
<td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td>
</tr>
<tr>
<td>:1,10d</td>
<td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td>
</tr>
<tr>
<td>:1, 10 m 20</td>
<td>将第1-10行移动到第20行之后。</td>
</tr>
</tbody></table>
<p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p>
<h4 id="4-2-6-退出命令"><a href="#4-2-6-退出命令" class="headerlink" title="4.2.6 退出命令"></a>4.2.6 退出命令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>ZZ</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出并忽略所有更改</td>
</tr>
<tr>
<td>:e!</td>
<td>放弃所有修改，并打开原来文件。</td>
</tr>
<tr>
<td>:q</td>
<td>未修改直接退出</td>
</tr>
</tbody></table>
<h4 id="4-2-7-注释命令"><a href="#4-2-7-注释命令" class="headerlink" title="4.2.7 注释命令"></a>4.2.7 注释命令</h4><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>3,5 s/^/#/g</td>
<td>注释第3-5行</td>
</tr>
<tr>
<td>3,5 s/^#//g</td>
<td>解除3-5行的注释</td>
</tr>
<tr>
<td>1,$ s/^/#/g</td>
<td>注释整个文档。</td>
</tr>
<tr>
<td>:%s/^/#/g</td>
<td>注释整个文档，此法更快。</td>
</tr>
</tbody></table>
<h3 id="4-3-执行shell命令"><a href="#4-3-执行shell命令" class="headerlink" title="4.3 执行shell命令"></a>4.3 执行shell命令</h3><ul>
<li>:!command</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:!ls</td>
<td>列出当前目录下文件</td>
</tr>
<tr>
<td>:!perl -c script.pl</td>
<td>检查perl脚本语法，可以不用退出vim，非常方便。</td>
</tr>
<tr>
<td>:!perl script.pl</td>
<td>执行perl脚本，可以不用退出vim，非常方便。</td>
</tr>
<tr>
<td>:suspend或Ctrl - Z</td>
<td>挂起vim，回到shell，按fg可以返回vim。</td>
</tr>
</tbody></table>
<h3 id="4-4-帮助命令"><a href="#4-4-帮助命令" class="headerlink" title="4.4 帮助命令"></a>4.4 帮助命令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:help or F1</td>
<td>显示整个帮助</td>
</tr>
<tr>
<td>:help xxx</td>
<td>显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。</td>
</tr>
<tr>
<td>:help ‘number’</td>
<td>Vim选项的帮助用单引号括起</td>
</tr>
<tr>
<td>:help &lt;Esc&gt;</td>
<td>特殊键的帮助用&lt;&gt;扩起</td>
</tr>
<tr>
<td>:help -t</td>
<td>Vim启动参数的帮助用-</td>
</tr>
<tr>
<td>：help i_&lt;Esc&gt;</td>
<td>插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式</td>
</tr>
</tbody></table>
<p>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p>
<h3 id="4-5-其他非编辑命令"><a href="#4-5-其他非编辑命令" class="headerlink" title="4.5 其他非编辑命令"></a>4.5 其他非编辑命令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>重复前一次命令</td>
</tr>
<tr>
<td>:set ruler?</td>
<td>查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</td>
</tr>
<tr>
<td>:scriptnames</td>
<td>查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</td>
</tr>
<tr>
<td>:set list</td>
<td>显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了 expandtab，那么tab将被扩展为空格。</td>
</tr>
</tbody></table>
<ul>
<li>Vim教程<ul>
<li>在Unix系统上 $ vimtutor</li>
<li>在Windows系统上 :help tutor</li>
</ul>
</li>
<li>录制宏:<ul>
<li>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</li>
</ul>
</li>
<li>:syntax 列出已经定义的语法项</li>
<li>:syntax clear 清除已定义的语法规则</li>
<li>:syntax case match 大小写敏感，int和Int将视为不同的语法元素</li>
<li>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</li>
</ul>
<h1 id="关机、重启和用户登录注销"><a href="#关机、重启和用户登录注销" class="headerlink" title="关机、重启和用户登录注销"></a>关机、重启和用户登录注销</h1><h2 id="1-关机-amp-重启命令"><a href="#1-关机-amp-重启命令" class="headerlink" title="1. 关机&amp;重启命令"></a>1. 关机&amp;重启命令</h2><h3 id="1-1-shutdown"><a href="#1-1-shutdown" class="headerlink" title="1.1 shutdown"></a>1.1 shutdown</h3><ul>
<li>shutdown -h now：表示立即关机</li>
<li>shutdown -h 1：表示1分钟后关机</li>
<li>shutdown -r now：立即重启</li>
</ul>
<h3 id="1-2-halt"><a href="#1-2-halt" class="headerlink" title="1.2 halt"></a>1.2 halt</h3><ul>
<li>halt：直接使用，关机</li>
</ul>
<h3 id="1-3-reboot"><a href="#1-3-reboot" class="headerlink" title="1.3 reboot"></a>1.3 reboot</h3><ul>
<li>reboot 重启系统</li>
</ul>
<h3 id="1-4-sync"><a href="#1-4-sync" class="headerlink" title="1.4 sync"></a>1.4 sync</h3><ul>
<li>sync：把内存的数据同步到磁盘上</li>
</ul>
<blockquote>
<p>当我们关机或者重启时，都应该先执行一下sync，防止数据丢失。</p>
</blockquote>
<h2 id="2-用户登录注销"><a href="#2-用户登录注销" class="headerlink" title="2. 用户登录注销"></a>2. 用户登录注销</h2><ul>
<li>登录时少用root账号登录，以避免操作失误的损失</li>
<li>平时可登录普通账户，再用“su - 用户名”切换成管理员登录</li>
</ul>
<h3 id="2-1-logout"><a href="#2-1-logout" class="headerlink" title="2.1 logout"></a>2.1 logout</h3><ul>
<li>logout：注销用户</li>
</ul>
<blockquote>
<p>在图形运行级别无效，在运行级别3有效。</p>
</blockquote>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="1-基本用户管理"><a href="#1-基本用户管理" class="headerlink" title="1. 基本用户管理"></a>1. 基本用户管理</h2><blockquote>
<ul>
<li>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li>
<li>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</li>
<li>每个用户账号都拥有一个唯一的用户名和各自的口令。</li>
<li>要完成的工作主要有如下几个方面：<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><blockquote>
<p>添加用户：useradd [选项] 用户名。</p>
</blockquote>
<h4 id="1-1-1-参数说明"><a href="#1-1-1-参数说明" class="headerlink" title="1.1.1 参数说明"></a>1.1.1 参数说明</h4><ul>
<li>选项:<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
<li>-f [缓冲天数] 指定在密码过期后多少天即关闭该帐号。</li>
<li>-e 有效期限 指定帐号的有效期限；</li>
<li>-M：不要自动建立用户的登入目录；</li>
</ul>
</li>
<li>用户名:<ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<h4 id="1-1-2-实例"><a href="#1-1-2-实例" class="headerlink" title="1.1.2 实例"></a>1.1.2 实例</h4><ol>
<li>useradd –d  /home/sam -m sam<ul>
<li>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。</li>
</ul>
</li>
<li>useradd -s /bin/sh -g group –G adm,root gem<ul>
<li>新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</li>
</ul>
</li>
</ol>
<h3 id="1-2-用户口令的管理"><a href="#1-2-用户口令的管理" class="headerlink" title="1.2 用户口令的管理"></a>1.2 用户口令的管理</h3><blockquote>
<p>指定和修改用户口令: passwd 选项 用户名</p>
</blockquote>
<h4 id="1-2-1-参数说明"><a href="#1-2-1-参数说明" class="headerlink" title="1.2.1 参数说明"></a>1.2.1 参数说明</h4><ul>
<li>选项：<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-注意事项"><a href="#1-2-2-注意事项" class="headerlink" title="1.2.2 注意事项"></a>1.2.2 注意事项</h4><ul>
<li>如果默认用户名，则修改当前用户的口令。<ul>
<li>假设当前用户是sam，则下面的命令修改该用户自己的口令：passwd sam</li>
</ul>
</li>
<li>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；</li>
<li>超级用户为用户指定口令时，就不需要知道原口令。</li>
</ul>
<h4 id="1-2-3-案例"><a href="#1-2-3-案例" class="headerlink" title="1.2.3 案例"></a>1.2.3 案例</h4><ol>
<li>passwd -l sam<ul>
<li>用 -l(lock) 选项锁定某一用户，使其不能登录</li>
</ul>
</li>
<li>passwd -d sam<ul>
<li>为用户指定空口令</li>
</ul>
</li>
</ol>
<h3 id="1-3-删除帐号"><a href="#1-3-删除帐号" class="headerlink" title="1.3 删除帐号"></a>1.3 删除帐号</h3><blockquote>
<p>删除帐号: userdel 选项 用户名</p>
</blockquote>
<h4 id="1-3-1-注意事项"><a href="#1-3-1-注意事项" class="headerlink" title="1.3.1 注意事项"></a>1.3.1 注意事项</h4><ul>
<li>常用的选项是 -r，它的作用是把用户的主目录一起删除。<ul>
<li>userdel -r sam</li>
</ul>
</li>
</ul>
<h3 id="1-4-修改帐号"><a href="#1-4-修改帐号" class="headerlink" title="1.4 修改帐号"></a>1.4 修改帐号</h3><blockquote>
<p>修改已有用户的信息: usermod 选项 用户名</p>
</blockquote>
<h4 id="1-4-1-注意事项"><a href="#1-4-1-注意事项" class="headerlink" title="1.4.1 注意事项"></a>1.4.1 注意事项</h4><ul>
<li>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</li>
</ul>
<h3 id="1-5-查询用户信息"><a href="#1-5-查询用户信息" class="headerlink" title="1.5 查询用户信息"></a>1.5 查询用户信息</h3><ul>
<li>查询用户信息: id 用户名<ul>
<li>用户不存在是返回“无此用户”</li>
</ul>
</li>
<li>查看当前用户/登录用户：who am i</li>
</ul>
<h3 id="1-6-切换用户"><a href="#1-6-切换用户" class="headerlink" title="1.6 切换用户"></a>1.6 切换用户</h3><ul>
<li>切换用户：su - 切换用户名<ul>
<li>从权限高切换到权限低的用户不需要输密码。</li>
<li>返回切换前的用户：exit</li>
</ul>
</li>
</ul>
<h2 id="2-用户组的管理"><a href="#2-用户组的管理" class="headerlink" title="2. 用户组的管理"></a>2. 用户组的管理</h2><blockquote>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。<br>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
</blockquote>
<h3 id="2-1-增加一个新的用户组"><a href="#2-1-增加一个新的用户组" class="headerlink" title="2.1 增加一个新的用户组"></a>2.1 增加一个新的用户组</h3><blockquote>
<p>增加一个新的用户组: groupadd 选项 用户组</p>
</blockquote>
<h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><ul>
<li>选项有：<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-案例"><a href="#2-1-2-案例" class="headerlink" title="2.1.2 案例"></a>2.1.2 案例</h4><ol>
<li>groupadd -g 101 group2<ul>
<li>向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</li>
</ul>
</li>
<li>groupadd -g 101 group2<ul>
<li>向系统中增加了一个新组group2，同时指定新组的组标识号是101。</li>
</ul>
</li>
</ol>
<h3 id="2-2-删除用户组"><a href="#2-2-删除用户组" class="headerlink" title="2.2 删除用户组"></a>2.2 删除用户组</h3><blockquote>
<p>删除用户组: groupmod 选项 用户组</p>
</blockquote>
<h4 id="2-1-2-说明"><a href="#2-1-2-说明" class="headerlink" title="2.1.2 说明"></a>2.1.2 说明</h4><ul>
<li>选项有：<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
</li>
</ul>
<h4 id="2-1-3-案例"><a href="#2-1-3-案例" class="headerlink" title="2.1.3 案例"></a>2.1.3 案例</h4><ol>
<li>groupmod -g 102 group2<ul>
<li>将组group2的组标识号修改为102。</li>
</ul>
</li>
<li>groupmod –g 10000 -n group3 group2<ul>
<li>将组group2的标识号改为10000，组名修改为group3。</li>
</ul>
</li>
</ol>
<h3 id="2-3-组的切换"><a href="#2-3-组的切换" class="headerlink" title="2.3 组的切换"></a>2.3 组的切换</h3><blockquote>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<ul>
<li>$ newgrp root<ul>
<li>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-与用户账号有关的系统文件"><a href="#3-与用户账号有关的系统文件" class="headerlink" title="3. 与用户账号有关的系统文件"></a>3. 与用户账号有关的系统文件</h2><h3 id="3-1-etc-passwd-文件"><a href="#3-1-etc-passwd-文件" class="headerlink" title="3.1 /etc/passwd 文件"></a>3.1 /etc/passwd 文件</h3><blockquote>
<p>用户（user）的配置文件，记录用户的各种信息。</p>
</blockquote>
<ul>
<li><p>每行的含义：</p>
<ol>
<li><p>“用户名”是代表用户账号的字符串。</p>
<ul>
<li>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</li>
<li>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</li>
</ul>
</li>
<li><p>“口令”一些系统中，存放着加密后的用户口令字。</p>
<ul>
<li>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li>
</ul>
</li>
<li><p>“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<ul>
<li>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</li>
<li>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</li>
</ul>
</li>
<li><p>“组标识号”字段记录的是用户所属的用户组。</p>
<ul>
<li>它对应着/etc/group文件中的一条记录。</li>
</ul>
</li>
<li><p>“注释性描述”字段记录着用户的一些个人情况。</p>
<ul>
<li>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</li>
</ul>
</li>
<li><p>“主目录”，也就是用户的起始工作目录。</p>
<ul>
<li>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li>
</ul>
</li>
<li><p>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<ul>
<li>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</li>
<li>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</li>
<li>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</li>
<li>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</li>
</ul>
</li>
<li><p>系统中有一类用户称为伪用户（pseudo users）。</p>
<ul>
<li>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-2-etc-shadow-文件"><a href="#3-2-etc-shadow-文件" class="headerlink" title="3.2 /etc/shadow 文件"></a>3.2 /etc/shadow 文件</h3><blockquote>
<p>口令配置文件</p>
</blockquote>
<ul>
<li><p>每行的含义：</p>
<ol>
<li><p>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</p>
</li>
<li><p>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</p>
</li>
<li><p>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</p>
</li>
<li><p>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</p>
</li>
<li><p>“最大时间间隔”指的是口令保持有效的最大天数。</p>
</li>
<li><p>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</p>
</li>
<li><p>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</p>
</li>
<li><p>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</p>
</li>
</ol>
</li>
</ul>
<h3 id="3-3-etc-group-文件"><a href="#3-3-etc-group-文件" class="headerlink" title="3.3 /etc/group 文件"></a>3.3 /etc/group 文件</h3><blockquote>
<p>组（group）的配置文件，用户组的所有信息都存放在/etc/group文件中。</p>
</blockquote>
<ul>
<li><p>每行含义：</p>
<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
</li>
</ul>
<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h2 id="1-指定运行级别（7个级别）"><a href="#1-指定运行级别（7个级别）" class="headerlink" title="1. 指定运行级别（7个级别）"></a>1. 指定运行级别（7个级别）</h2><ul>
<li>0.关机</li>
<li>1.单用户【找回丢失密码】</li>
<li>2.多用户状态没有网络服务</li>
<li>3.多用户状态有网络服务</li>
<li>4.系统未使用保留给用户</li>
<li>5.图形界面</li>
<li>6.系统重启</li>
<li>系统的运行级别配置文件：/etc/inittab</li>
<li>切换到指定运行级别的指令：init [012356]</li>
</ul>
<h2 id="2-帮助指令"><a href="#2-帮助指令" class="headerlink" title="2. 帮助指令"></a>2. 帮助指令</h2><h3 id="2-1-man获得帮助信息"><a href="#2-1-man获得帮助信息" class="headerlink" title="2.1 man获得帮助信息"></a>2.1 man获得帮助信息</h3><blockquote>
<p>man [命令或配置文件]</p>
</blockquote>
<ul>
<li>例如:man ls</li>
</ul>
<h3 id="2-2-help指令"><a href="#2-2-help指令" class="headerlink" title="2.2 help指令"></a>2.2 help指令</h3><blockquote>
<p>help [命令或配置文件]</p>
</blockquote>
<h2 id="3-文件目录类指令"><a href="#3-文件目录类指令" class="headerlink" title="3. 文件目录类指令"></a>3. 文件目录类指令</h2><h3 id="3-1-文件剪贴删除复制重名等"><a href="#3-1-文件剪贴删除复制重名等" class="headerlink" title="3.1 文件剪贴删除复制重名等"></a>3.1 文件剪贴删除复制重名等</h3><ul>
<li>pwd：Print Working Directory，显示当前工作目录的绝对路径。</li>
<li>ls：-a：显示当前目录所有的文件和目录，包括隐藏的；<ul>
<li>-l：以列表的方式显示信息。</li>
</ul>
</li>
<li>cd：cd ~：回到自己的家目录；cd …：回到当前目录的上一级目录。</li>
<li>mkdir：创建目录；-p：创建多级目录。</li>
<li>rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。</li>
<li>cp：拷贝文件到指定目录；<ul>
<li>-r：递归复制整个文件夹。强制覆盖不提示的方法：</li>
<li>cp命令改为\cp</li>
</ul>
</li>
<li>rm：移除文件或目录；<ul>
<li>-r：递归删除整个文件夹；</li>
<li>-f：强制删除不提示。</li>
</ul>
</li>
<li>mv：移动文件与目录或重命名，两种功能！</li>
<li>touch：创建空文件。可以一次性创建多个文件</li>
<li>ln 给文件创建一个软连接<ul>
<li>用法:ln -s[源文件或目录][软连接名]</li>
</ul>
</li>
</ul>
<h3 id="3-2-文件查看"><a href="#3-2-文件查看" class="headerlink" title="3.2 文件查看"></a>3.2 文件查看</h3><ul>
<li>cat：查看文件内容。只能浏览文件，而不能修改文件。<ul>
<li>-n：显示行号。</li>
<li>结尾加上 | more：分页显示，不会全部一下显示完。</li>
</ul>
</li>
<li>more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键：<ul>
<li>空白键（Space）：向下翻一页</li>
<li>Enter：向下翻一行</li>
<li>q：立刻离开more，不再显示该文件内容</li>
<li>Ctrl + F：向下滚动一屏</li>
<li>Ctrl + B：返回上一屏</li>
<li>= :输出当前行的行号</li>
<li>:f 输出文件名和当前行的行号</li>
</ul>
</li>
<li>less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。</li>
<li>head：显示文件的开头部分。-n 5：看前面5行内容。</li>
<li>tail：输出文件中尾部的内容。<ul>
<li>-n 5：看后面5行内容。</li>
<li>-f：时事追踪该文档的所有更新</li>
</ul>
</li>
<li>&gt;指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。</li>
<li>&gt;&gt;指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。</li>
<li>echo：输出内容到控制台。</li>
<li>history：查看历史指令</li>
</ul>
<h3 id="3-3-时间和日期"><a href="#3-3-时间和日期" class="headerlink" title="3.3 时间和日期"></a>3.3 时间和日期</h3><ul>
<li>date：显示当前日期和时间<ul>
<li>date “+%Y”：显示当前年份</li>
<li>date “+%d”：显示当前月份</li>
<li>date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒</li>
<li>设置日期：date -s 字符串时间</li>
</ul>
</li>
<li>cal：查看日历指令；<ul>
<li>cal [月] [年份]：显示某一年或月的日历</li>
</ul>
</li>
</ul>
<h3 id="3-4-搜索查找类"><a href="#3-4-搜索查找类" class="headerlink" title="3.4 搜索查找类"></a>3.4 搜索查找类</h3><ul>
<li>find：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。<ul>
<li>find (搜索范围) -name (文件名)：按照指定的文件名查找模式查找文件。</li>
<li>find (搜索范围) -user (用户名)：按照指定的用户名查找模式查找文件。</li>
<li>find (搜索范围) -size (+多少/-多少/多少)：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少）</li>
<li>查询 /目录下所有.txt的文件：find / -name *.txt</li>
</ul>
</li>
<li>locate：locate (搜索文件)<ul>
<li>可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。</li>
<li>locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</li>
<li>在第一次运行之前，必须使用updatedb指令创建locate数据库。</li>
</ul>
</li>
<li>grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。<ul>
<li>grep [选项] 查找内容 源文件</li>
<li>-n：显示匹配行及行号。</li>
<li>-i：忽略大小写字母。</li>
<li>cat hello.txt | grep yes</li>
</ul>
</li>
</ul>
<h3 id="3-5-压缩和解压类"><a href="#3-5-压缩和解压类" class="headerlink" title="3.5 压缩和解压类"></a>3.5 压缩和解压类</h3><ul>
<li>gzip/gunzip：压缩文件/解压<ul>
<li>gzip (文件)：压缩为.gz文件，原来文件不保留。</li>
<li>gunzip (文件)：解压缩，同样也不保留源文件。</li>
</ul>
</li>
<li>zip/unzip：压缩文件/解压<ul>
<li>zip [选项] (压缩后文件xxx.zip) (将要压缩的文件)</li>
<li>unzip [选项] (要解压的文件xxx.zip)</li>
<li>zip -r：递归压缩，即压缩目录</li>
<li>unzip -d (目录)：指定解压后的文件的存放目录</li>
</ul>
</li>
<li>tar：打包指令，最后打包后的文件是.tar.gz的文件<ul>
<li>tar [选项] xxx.tar.gz (打包的内容)</li>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细信息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩</li>
<li>-x：解压.tar文件</li>
<li>压缩：tar -zcvf (压缩后文件名) (要压缩的文件)</li>
<li>解压：tar -zxvf (要解压的文件)</li>
<li>解压到指定目录：tar -zxvf (要解压的文件) -C (指定目录)，指定解压到的目录要存在。</li>
</ul>
</li>
</ul>
<h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><h2 id="1-Linux组基本介绍"><a href="#1-Linux组基本介绍" class="headerlink" title="1. Linux组基本介绍"></a>1. Linux组基本介绍</h2><ul>
<li>Linux中每个用户属于一个组，不能独立于组以外。所以在Linux中每个文件存在组的概念：<ol>
<li>所有者</li>
<li>所在组</li>
<li>其他组</li>
<li>改变用户所在组</li>
</ol>
</li>
</ul>
<h2 id="2-文件-目录所有者"><a href="#2-文件-目录所有者" class="headerlink" title="2. 文件/目录所有者"></a>2. 文件/目录所有者</h2><blockquote>
<p>一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。</p>
</blockquote>
<ul>
<li>查看文件所有者：ls -ahl</li>
<li>修改文件所有者：chown (用户名) (文件名)</li>
</ul>
<h2 id="3-文件-目录所在组"><a href="#3-文件-目录所在组" class="headerlink" title="3. 文件/目录所在组"></a>3. 文件/目录所在组</h2><blockquote>
<p>当某个用户创建了一个文件之后，默认之歌文件所在组就是该用户所在的组</p>
</blockquote>
<ul>
<li>查看文件所有者：ls -ahl</li>
<li>修改文件所在组：chgrp (组名) (文件名)</li>
</ul>
<h2 id="4-其他组"><a href="#4-其他组" class="headerlink" title="4. 其他组"></a>4. 其他组</h2><blockquote>
<p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</p>
</blockquote>
<h2 id="5-文件属性"><a href="#5-文件属性" class="headerlink" title="5. 文件属性"></a>5. 文件属性</h2><ul>
<li>ls -l中显示的内容如图所示</li>
</ul>
<ol>
<li>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。<ul>
<li>当为[ d ]则是目录</li>
<li>当为[ - ]则是文件；</li>
<li>若是[ l ]则表示为链接文档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
</li>
<li>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>每个文件的属性由左边第一部分的10个字符来确定（如下图）。</li>
</ol>
<h3 id="5-1-rwx权限详解"><a href="#5-1-rwx权限详解" class="headerlink" title="5.1 rwx权限详解"></a>5.1 rwx权限详解</h3><ul>
<li>rwx作用到文件：<ul>
<li>r：read，可读。读取查看。</li>
<li>w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li>
<li>x：execute，可执行。可以被执行。</li>
</ul>
</li>
<li>rwx作用到目录：<ul>
<li>r：可以读取，ls查看目录内容。</li>
<li>w：可以修改，目录内创建+删除+重命名目录。</li>
<li>x：可执行，可以进入该目录。</li>
</ul>
</li>
</ul>
<h3 id="5-2-修改权限"><a href="#5-2-修改权限" class="headerlink" title="5.2 修改权限"></a>5.2 修改权限</h3><h4 id="5-2-1-chgrp：更改文件属组"><a href="#5-2-1-chgrp：更改文件属组" class="headerlink" title="5.2.1 chgrp：更改文件属组"></a>5.2.1 chgrp：更改文件属组</h4><ul>
<li>chgrp [-R] 属组名 文件名<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
</li>
</ul>
<h4 id="5-2-2-chown：更改文件属主，也可以同时更改文件属组"><a href="#5-2-2-chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="5.2.2 chown：更改文件属主，也可以同时更改文件属组"></a>5.2.2 chown：更改文件属主，也可以同时更改文件属组</h4><blockquote>
<p>语法:</p>
<ul>
<li>chown [–R] 属主名 文件名</li>
<li>chown [-R] 属主名：属组名 文件名</li>
</ul>
</blockquote>
<h4 id="5-2-3-chmod：更改文件9个属性"><a href="#5-2-3-chmod：更改文件9个属性" class="headerlink" title="5.2.3 chmod：更改文件9个属性"></a>5.2.3 chmod：更改文件9个属性</h4><ul>
<li>Linux文件属性有两种设置方法，一种是数字，一种是符号。</li>
<li>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</li>
<li>我们可以使用数字来代表各个权限，各权限的分数对照表如下：<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
</li>
<li>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
</li>
</ul>
<h5 id="5-2-3-1-使用数字修改权限"><a href="#5-2-3-1-使用数字修改权限" class="headerlink" title="5.2.3.1 使用数字修改权限"></a>5.2.3.1 使用数字修改权限</h5><ul>
<li><strong>chmod [-R] xyz 文件或目录</strong><ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
</li>
</ul>
<h5 id="5-2-3-1-使用符号修改权限"><a href="#5-2-3-1-使用符号修改权限" class="headerlink" title="5.2.3.1 使用符号修改权限"></a>5.2.3.1 使用符号修改权限</h5><ul>
<li>我们就可以使用 u(user), g(group), o(others) 来代表三种身份的权限！</li>
<li>此外， a 则代表 all，即全部的身份。</li>
<li><h1 id="3-7定时任务调度"><a href="#3-7定时任务调度" class="headerlink" title="3.7定时任务调度"></a>3.7定时任务调度</h1></li>
</ul>
<h1 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h1><h2 id="1-任务调度原理"><a href="#1-任务调度原理" class="headerlink" title="1. 任务调度原理"></a>1. 任务调度原理</h2><blockquote>
<p>crond任务调度：crontab进行定时任务调度  </p>
</blockquote>
<ul>
<li>使用方法：crontab [选项]<ul>
<li>crontab [选项]</li>
<li>-e：编辑crontab定时任务</li>
<li>-i：查询crontab任务</li>
<li>-r：删除当前用户所有的crontab任务</li>
<li>-l：列出当前有哪些任务调度</li>
<li>service crond restart：重启任务调度</li>
<li>当保存退出后就生效了</li>
<li>参数细节说明</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody></table>
<ul>
<li>特殊符号说明<ul>
<li><code>\*：</code>代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思。</li>
<li><code>,：</code>代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</li>
<li><code>-：</code>代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。</li>
<li><code>/n：</code>代表每隔多久执行一次。比如“<em>/10 \</em> * * * 命令”，代表每隔10分钟就执行一遍命令。</li>
</ul>
</li>
</ul>
<h1 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h1><h2 id="1-RPM包"><a href="#1-RPM包" class="headerlink" title="1. RPM包"></a>1. RPM包</h2><blockquote>
<p>RPM：RedHat Package Manager，红帽软件包管理工具。<br>Linuxd分发版本都有采用（suse,redhat，centos等）</p>
</blockquote>
<h3 id="1-1-rpm指令"><a href="#1-1-rpm指令" class="headerlink" title="1.1 rpm指令"></a>1.1 rpm指令</h3><h4 id="1-1-1-查看指令"><a href="#1-1-1-查看指令" class="headerlink" title="1.1.1 查看指令"></a>1.1.1 查看指令</h4><ul>
<li>RPM查询已安装的rpm列表：rpm -qa | grep xx<ul>
<li>查看是否安装firefox：rpm -qa |grep firefox</li>
<li>如果是i686,i386表示32位系统，noarch表示通用</li>
</ul>
</li>
<li>rpm -qa：查询所安装的所有rpm软件包</li>
<li>rpm -qa | more</li>
<li>rpm -qa | grep xx</li>
<li>rpm -q xx：查询xx软件包是否安装</li>
<li>rpm -qi xx：查询软件包信息</li>
<li>rpm -ql xx：查询软件包中的文件</li>
<li>rpm -qf 文件全路径名：查询文件所属的软件包</li>
</ul>
<h4 id="1-1-2-卸载指令"><a href="#1-1-2-卸载指令" class="headerlink" title="1.1.2 卸载指令"></a>1.1.2 卸载指令</h4><ul>
<li>卸载rpm包：rpm -e 软件包名称</li>
<li>如果其他软件依赖于要卸载的包，删除时可能会发生依赖错误</li>
<li>忽视依赖强制删除的方法：rpm -e –nodeps 软件包名称 可以强制删除，但不建议这样做，否则会导致程序无法运行</li>
</ul>
<h4 id="1-1-3安装指令"><a href="#1-1-3安装指令" class="headerlink" title="1.1.3安装指令"></a>1.1.3安装指令</h4><ul>
<li>安装rpm包：rpm -ivh 软件包全路径名称<ul>
<li>i=install：安装</li>
<li>v=verbose：提示</li>
<li>h=hash：进度条</li>
</ul>
</li>
</ul>
<h2 id="2-YUM"><a href="#2-YUM" class="headerlink" title="2. YUM"></a>2. YUM</h2><blockquote>
<p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。<br>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
</blockquote>
<ul>
<li>yum list | grep xx：查询yum服务器是否有需要安装的软件</li>
<li>yum install xx：安装指定的yum包</li>
<li>yum -y remove xx：卸载指定的yum包</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mybatis中使用逆向工程</title>
    <url>/2020/11/11/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>mybatis中使用逆向工程</p>
<p>首先导入maven</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.7&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;verbose&gt;true&lt;&#x2F;verbose&gt;</span><br><span class="line">                    &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt;</span><br><span class="line">                    &lt;configurationFile&gt;</span><br><span class="line">                        src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml</span><br><span class="line">                    &lt;&#x2F;configurationFile&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis.generator&#x2F;mybatis-generator-core --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">                        &lt;version&gt;1.3.7&lt;&#x2F;version&gt;</span><br><span class="line">                    &lt;&#x2F;dependency&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">                        &lt;version&gt;8.0.15&lt;&#x2F;version&gt;</span><br><span class="line">                    &lt;&#x2F;dependency&gt;</span><br><span class="line">                &lt;&#x2F;dependencies&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<p>建立generatorconfig.xml，然后输入以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;context id&#x3D;&quot;testTables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;employee?serverTimezone&#x3D;UTC&quot; userId&#x3D;&quot;root&quot;</span><br><span class="line">                        password&#x3D;&quot;0606&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;nullCatalogMeansCurrent&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;&#x2F;jdbcConnection&gt;</span><br><span class="line">        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和</span><br><span class="line">            NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- targetProject:生成PO类的位置 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage&#x3D;&quot;com.generatodemo.my01.demo.pojo&quot;</span><br><span class="line">                            targetProject&#x3D;&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.mapper&quot;</span><br><span class="line">                         targetProject&#x3D;&quot;.\src\main\resources&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot;</span><br><span class="line">                             targetPackage&#x3D;&quot;com.generatodemo.my01.demo.pojo.mapper&quot;</span><br><span class="line">                             targetProject&#x3D;&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 指定数据库表 --&gt;</span><br><span class="line">        &lt;!-- &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;tb_item&quot; domainObjectName&#x3D;&quot;Item&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">            domainObjectName 可以配置生成的pojo名字</span><br><span class="line">            如不需要example类添加下面四个属性</span><br><span class="line">            enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot;</span><br><span class="line">            enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt;--&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;employee&quot; domainObjectName&#x3D;&quot;employee&quot; enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot;</span><br><span class="line">               enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;department&quot; domainObjectName&#x3D;&quot;department&quot; enableCountByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot;</span><br><span class="line">               enableSelectByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">    &lt;&#x2F;context&gt;</span><br><span class="line">&lt;&#x2F;generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>

<p>最后点击</p>
<p><img src= "/img/loading.gif" data-src="%E6%8D%95%E8%8E%B7.PNG" alt="捕获"></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式七大原则</title>
    <url>/2020/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><p>设计模式常用的七大原则有:</p>
<p>单一职责原则</p>
<p>接口隔离原则</p>
<p>依赖倒转(倒置)原则</p>
<p>里氏替换原则</p>
<p>开闭原则</p>
<p>迪米特法则</p>
<p>合成复用原则</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>​    对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>
<h3 id="单一职责原则注意事项和细节"><a href="#单一职责原则注意事项和细节" class="headerlink" title="单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h3><ol>
<li>降低类的复杂度，一个类只负责一项职责。 </li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>​    客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p>
<h3 id="接口隔离原则注意事项和细节"><a href="#接口隔离原则注意事项和细节" class="headerlink" title="接口隔离原则注意事项和细节"></a>接口隔离原则注意事项和细节</h3><p>接口 Interface 中出现的方法，根据实际情况拆分为三个接口然后不同的类去继承多个小的接口，实现接口的隔离。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是面向接口编程</li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
<h3 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h3><ol>
<li>接口传递</li>
<li>构造方法传递应用案例代码</li>
<li>setter 方式传递</li>
</ol>
<h3 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h3><ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li>
<li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ol>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。</li>
</ol>
<h3 id="里氏替换通用方法"><a href="#里氏替换通用方法" class="headerlink" title="里氏替换通用方法"></a>里氏替换通用方法</h3><p>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替.</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ol>
<li>开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</li>
<li>一个软件实体如类，模块和函数应该对扩展开放<strong>(</strong>对提供方<strong>)</strong>，对修改关闭<strong>(</strong>对使用方<strong>)</strong>。用抽象构建框架，用实现扩展细节。</li>
<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>
<li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>
</ol>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li>
<li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<h3 id="迪米特法则注意事项"><a href="#迪米特法则注意事项" class="headerlink" title="迪米特法则注意事项"></a>迪米特法则注意事项</h3><ol>
<li>迪米特法则的核心是降低类之间的耦合</li>
<li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<h2 id="设计模式的核心思想是"><a href="#设计模式的核心思想是" class="headerlink" title="设计模式的核心思想是"></a>设计模式的核心思想是</h2><ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>土到极致就是潮 </title>
    <url>/2021/03/23/%E5%9C%9F%E5%88%B0%E6%9E%81%E8%87%B4%E5%B0%B1%E6%98%AF%E6%BD%AE%20/</url>
    <content><![CDATA[<p>土到极致就是潮</p>
<p>一个在线的电子相册，哄女朋友就好使，直接可以发出来</p>
<p>效果不亚于某宝的土味礼物</p>
<p>没服务器也没关系，可以使用github或者gitee的页面托管，我下面的网址就是托管在gitee上了</p>
<p>建立一个文件夹，照片命名并保存</p>
<p>可以生成静态页面，然后就可以访问了</p>
<p>演示地址<a href="http://codelin666.gitee.io/album" target="_blank" rel="noopener">http://codelin666.gitee.io/album</a></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;title&gt;电子相册&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
  html{
  width: 100%;
  height: 100%;
}
.bigbox{
  width: 10px;
  height: 10px;
  margin: 200px 400px;
  position: relative;
}
.box{
  width:500px;
  height:300px;
  margin: 0 auto;
  transform-style: preserve-3d;
  transform: rotateX(-30deg) rotateY(-80deg);
  -webkit-animation: mystyle 15s infinite;
  animation-timing-function: linear;
}
@-webkit-keyframes mystyle{
  from{transform: rotateX(-180deg) rotateY(-180deg);}
  to{transform: rotateX(180deg) rotateY(180deg);}
}
.box div{
  position: absolute;
  width: 200px;
  height: 200px;
  opacity: 0.8;
  transition: all .4s;
}
.bigpic{
  width: 200px;
  height: 200px;
}
.box .bigfront{
  transform: rotateY(0deg) translateZ(100px);
}
.box .bigback{
  transform: translateZ(-100px) rotateY(180deg);
}
.box .bigleft{
  transform: rotateY(90deg) translateZ(100px);
}
.box .bigright{
  transform: rotateY(-90deg) translateZ(100px);
}
.box .bigtop{
  transform: rotateX(90deg) translateZ(100px);
}
.box .bigbottom{
  transform: rotateX(-90deg) translateZ(100px);
}
.box span{
  display: block;
  position: absolute;
  width: 140px;
  height: 140px;
  top: 25px;
  left: 25px;
}
.box .smallpic{
  width: 140px;
  height: 140px;
}
.box .smallleft{
  transform: rotateY(90deg) translateZ(70px);
}
.box .smallright{
  transform: rotateY(-90deg) translateZ(70px);
}
.box .smalltop{
  transform: rotateX(90deg) translateZ(70px);
}
.box .smallbottom{
  transform: rotateX(-90deg) translateZ(70px);
}
.box .smallfront{
  transform: rotateY(0deg) translateZ(70px);
}
.box .smallback{
  transform: translateZ(-70px) rotateY(180deg);
}
/*:hover 我们之前说过的一个css选择器，能够让鼠标指向的时候触发*/
.box:hover .bigleft{
  transform: rotateY(90deg) translateZ(300px);
}
.box:hover .bigright{
  transform: rotateY(-90deg) translateZ(300px);
}
.box:hover .bigtop{
  transform: rotateX(90deg) translateZ(300px);
}
.box:hover .bigbottom{
  transform: rotateX(-90deg) translateZ(300px);
}
.box:hover .bigfront{
  transform: rotateY(0deg) translateZ(300px);
}
.box:hover .bigback{
  transform: translateZ(-300px) rotateY(180deg);
}
&lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
&lt;div class=&quot;bigbox&quot;&gt;
  &lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;bigfront&quot;&gt;
  &lt;img src=&quot;image/1.jpg&quot; class=&quot;bigpic&quot; &gt;
&lt;/div&gt;
&lt;div class=&quot;bigback&quot;&gt;
  &lt;img src=&quot;image/2.jpg&quot; class=&quot;bigpic&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;bigleft&quot;&gt;
  &lt;img src=&quot;image/3.jpg&quot; class=&quot;bigpic&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;bigright&quot;&gt;
  &lt;img src=&quot;image/4.jpg&quot; class=&quot;bigpic&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;bigtop&quot;&gt;
  &lt;img src=&quot;image/5.jpg&quot; class=&quot;bigpic&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;bigbottom&quot;&gt;
  &lt;img src=&quot;image/6.jpg&quot; class=&quot;bigpic&quot;&gt;
&lt;/div&gt;
&lt;span class=&quot;smallfront&quot;&gt;
  &lt;img src=&quot;image/7.jpg&quot; class=&quot;smallpic&quot; /&gt;
&lt;/span&gt;
&lt;span class=&quot;smallback&quot;&gt;
  &lt;img src=&quot;image/8.jpg&quot; class=&quot;smallpic&quot; /&gt;
&lt;/span&gt;
&lt;span class=&quot;smallleft&quot;&gt;
  &lt;img src=&quot;image/9.jpg&quot; class=&quot;smallpic&quot; /&gt;
&lt;/span&gt;
&lt;span class=&quot;smallright&quot;&gt;
  &lt;img src=&quot;image/10.jpg&quot; class=&quot;smallpic&quot; /&gt;
&lt;/span&gt;
&lt;span class=&quot;smalltop&quot;&gt;
  &lt;img src=&quot;image/11.jpg&quot; class=&quot;smallpic&quot; /&gt;
&lt;/span&gt;
&lt;span class=&quot;smallbottom&quot;&gt;
  &lt;img src=&quot;image/12.jpg&quot; class=&quot;smallpic&quot; /&gt;
&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>​    </p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC笔记 </title>
    <url>/2021/01/23/SpringMVC%E7%AC%94%E8%AE%B0%20/</url>
    <content><![CDATA[<p>一、SpringMVC简介<br>1.什么是MVC<br>Model：数据模型<br>View：视图<br>Controller：控制器</p>
<p>MVC是一种Web应用架构，是一种代码设计思想<br>思想：将所有客户端请求交由控制器，由控制器将其进行分发，并将结果响应给客户端。</p>
<p>2.常见MVC框架<br>使用原生Servlet实现MVC：</p>
<pre><code>配置比较复杂
数据处理太麻烦</code></pre><p>实际开发中一般都会使用MVC框架，如Struts1、Struts2、SpringMVC等</p>
<p>对比：</p>
<pre><code>效率方面，Struts1&gt;SpringMVC&gt;Struts2
Struts2是多例的，效率低
Struts1和SpringMVC是单例的，两者效率差不多。
配置方面：SpringMVC&gt;Struts2&gt;Struts1</code></pre><p>3.为什么使用SpringMVC</p>
<pre><code>使用注解来替代xml配置，更简单
是单例的，效率高
用户可以自定义，扩展性好
SpringMVC和Spring无缝衔接</code></pre><p>二、SpringMVC实现原理</p>
<p>DispatcherServlet<br>SpringMVC核心控制器(前端控制器)：主要是用来分发请求的</p>
<p>HandlerMapping<br>映射处理器：根据请求的url来映射查找到对应的Handler</p>
<p>Handler就是Controller层的实现类<br>HandlerAdapter<br>适配器：用来适配不同的处理器Handler<br>处理器有两种实现方式：实现接口、基于注解，所以执行前需要先适配</p>
<p>Handler<br>处理器：真正用来处理和执行业务，并产生数据模型Model和视图View，<br>Handler会将Model和View封装成ModelAndView对象并返回。</p>
<p>ViewResolver<br>视图解析器：根据视图名称解析成具体的视图，一般多为jsp页面，然后把它封装成View对象并返回。</p>
<p>三、RestFul 风格</p>
<p>RestFul 只是一种风格，基于这个风格设计的程序可以更简洁，有层次，更易于实现缓存等机制, 他实现了请求相同的路径而产生不同的逻辑的效果, 实现了 URL 复用</p>
<p>一般基于数据增删改查发出的请求，是通过==区分不同的路径==达到 CRUD 的效果，例如：</p>
<pre><code>localhost:8080/dropUser?id=1        删除用户
localhost:8080/finduser?id=1        查询用户</code></pre><p>而 RestFul 是通过==区分请求的方法==达到 CRUD 的效果，例如</p>
<pre><code>localhost:8080/user?id=1    删除用户    发出DELETE请求
localhost:8080/user?id=1    查询用户    发出GET请求</code></pre><p>在 RestFul 中针对增删改查分别对应着四种请求方法</p>
<p>［ 添加: POST ］［ 删除: DELETE ］［ 修改: PUT ］［ 查询: GET ］</p>
<p>针对区分四种请求的方法有两种手段：</p>
<pre><code>通过 RequestMapping 中的 method 属性进行区分请求

// 仅接收以post方法发出的请求
@RequestMapping(value=&quot;/user&quot;, method = RequestMethod.POST)

通过每个方法对应的注解进行区分

@PostMapping
@DeleteMapping
@PutMapping
@GetMapping</code></pre>]]></content>
  </entry>
  <entry>
    <title>Springboot </title>
    <url>/2021/02/23/Springboot%20/</url>
    <content><![CDATA[<p>SpringBoot<br>SpringBoot简介</p>
<p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架。</p>
<p>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</p>
<p>虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。</p>
<p>第一阶段：xml配置</p>
<p>在Spring 1.x时代，使用Spring开发满眼都是xml配置的Bean，随着项目的扩大，我们需要把xml配置文件放到不同的配置文件里，那时需要频繁的在开发的类和配置文件之间进行切换</p>
<p>第二阶段：注解配置</p>
<p>Spring提供了声明Bean的注解（例如@Component、@Service），大大减少了配置量。</p>
<p>SPringBoot运行原理<br>父依赖，其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p>
<p>spring-boot-dependencies管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p>启动器 spring-boot-starter</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；一个个starter就好似我们自己集成出来的一系列服务，可以自己选择开关。</p>
]]></content>
  </entry>
  <entry>
    <title>淦，跨域问题 </title>
    <url>/2021/05/23/%E6%B7%A6%EF%BC%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%20/</url>
    <content><![CDATA[<pre><code>@Configuration
public class CrosConfig implements WebMvcConfigurer {
@Override
public void addCorsMappings(CorsRegistry registry) {
registry.addMapping(&quot;/**&quot;)
.allowedOrigins(&quot;*&quot;)
.allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;)
.allowCredentials(true)
.maxAge(3600)
.allowedHeaders(&quot;*&quot;);
}
}</code></pre>]]></content>
  </entry>
</search>
